// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	OAuth2AuthorizationCodeScopes = "OAuth2AuthorizationCode.Scopes"
	OAuth2ClientCredsScopes       = "OAuth2ClientCreds.Scopes"
)

// AddToCartJSONBody defines parameters for AddToCart.
type AddToCartJSONBody struct {
	Items *[]struct {
		Modality *string  `json:"modality,omitempty"`
		Quantity *float32 `json:"quantity,omitempty"`
		Upc      *string  `json:"upc,omitempty"`
	} `json:"items,omitempty"`
}

// LocationListParams defines parameters for LocationList.
type LocationListParams struct {
	// FilterZipCodeNear The zip code you want to use as a starting point for results.
	FilterZipCodeNear *string `form:"filter.zipCode.near,omitempty" json:"filter.zipCode.near,omitempty"`

	// FilterLatLongNear The latitude and longitude you want to use as a starting point for results.
	FilterLatLongNear *string `form:"filter.latLong.near,omitempty" json:"filter.latLong.near,omitempty"`

	// FilterLatNear The latitude you want to use as a starting point for results.
	FilterLatNear *string `form:"filter.lat.near,omitempty" json:"filter.lat.near,omitempty"`

	// FilterLonNear The longitude you want to use as a starting point for results.
	FilterLonNear *string `form:"filter.lon.near,omitempty" json:"filter.lon.near,omitempty"`

	// FilterRadiusInMiles The mile radius you want results limited to.
	FilterRadiusInMiles *string `form:"filter.radiusInMiles,omitempty" json:"filter.radiusInMiles,omitempty"`

	// FilterLimit The number of results you want returned.
	FilterLimit *string `form:"filter.limit,omitempty" json:"filter.limit,omitempty"`

	// FilterChain The chain name of the chain you want results limited to. When using this filter, only stores matching the provided chain name are returned.
	FilterChain *string `form:"filter.chain,omitempty" json:"filter.chain,omitempty"`

	// FilterDepartment The departmentId of the department you want results limited to. Lists must be comma-separated. When using this filter, only stores who have all of the departments provided are returned.
	FilterDepartment *string `form:"filter.department,omitempty" json:"filter.department,omitempty"`
}

// ProductSearchParams defines parameters for ProductSearch.
type ProductSearchParams struct {
	// FilterTerm A search term to filter product results. As an example, you could input milk, bread, or salt.
	FilterTerm *string `form:"filter.term,omitempty" json:"filter.term,omitempty"`

	// FilterLocationId The locationId of the store you want results limited to. When using this filter, only products available at that location are returned.
	FilterLocationId *string `form:"filter.locationId,omitempty" json:"filter.locationId,omitempty"`

	// FilterProductId The productId of the products(s) you want returned. For more than one item, the list must be comma-separated. When used, all other query parameters are ignored.
	FilterProductId *string `form:"filter.productId,omitempty" json:"filter.productId,omitempty"`

	// FilterBrand The brand name of the product(s) you want returned. When using this filter, only products by that brand are returned. Brand names are case-sensitive, and lists must be pipe-separated.
	FilterBrand *string `form:"filter.brand,omitempty" json:"filter.brand,omitempty"`

	// FilterFulfillment The available fulfillment types of the product(s) you want returned. Fulfillment types are case-sensitive, and lists must be comma-separated. Must be one or more of the follow types: ais - Available In Store, csp - Curbside Pickup, dth - Delivery To Home, sth - Ship To Home
	FilterFulfillment *string `form:"filter.fulfillment,omitempty" json:"filter.fulfillment,omitempty"`

	// FilterStart The number of products you want to skip.
	FilterStart *string `form:"filter.start,omitempty" json:"filter.start,omitempty"`

	// FilterLimit The number of products you want returned.
	FilterLimit *string `form:"filter.limit,omitempty" json:"filter.limit,omitempty"`
}

// ProductDetailsParams defines parameters for ProductDetails.
type ProductDetailsParams struct {
	// FilterLocationId The locationId of the store you want results limited to. When using this filter, only products available at that location are returned.
	FilterLocationId *string `form:"filter.locationId,omitempty" json:"filter.locationId,omitempty"`
}

// AddToCartJSONRequestBody defines body for AddToCart for application/json ContentType.
type AddToCartJSONRequestBody AddToCartJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AddToCartWithBody request with any body
	AddToCartWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddToCart(ctx context.Context, body AddToCartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChainList request
	ChainList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChainDetails request
	ChainDetails(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DepartmentList request
	DepartmentList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DepartmentDetails request
	DepartmentDetails(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserProfileInformation request
	UserProfileInformation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LocationList request
	LocationList(ctx context.Context, params *LocationListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LocationDetails request
	LocationDetails(ctx context.Context, locationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductSearch request
	ProductSearch(ctx context.Context, params *ProductSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductDetails request
	ProductDetails(ctx context.Context, id string, params *ProductDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AddToCartWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddToCartRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddToCart(ctx context.Context, body AddToCartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddToCartRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChainList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChainListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChainDetails(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChainDetailsRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DepartmentList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDepartmentListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DepartmentDetails(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDepartmentDetailsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserProfileInformation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserProfileInformationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LocationList(ctx context.Context, params *LocationListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLocationListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LocationDetails(ctx context.Context, locationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLocationDetailsRequest(c.Server, locationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductSearch(ctx context.Context, params *ProductSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductDetails(ctx context.Context, id string, params *ProductDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductDetailsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAddToCartRequest calls the generic AddToCart builder with application/json body
func NewAddToCartRequest(server string, body AddToCartJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddToCartRequestWithBody(server, "application/json", bodyReader)
}

// NewAddToCartRequestWithBody generates requests for AddToCart with any type of body
func NewAddToCartRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cart/add")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChainListRequest generates requests for ChainList
func NewChainListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChainDetailsRequest generates requests for ChainDetails
func NewChainDetailsRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDepartmentListRequest generates requests for DepartmentList
func NewDepartmentListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/departments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDepartmentDetailsRequest generates requests for DepartmentDetails
func NewDepartmentDetailsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/departments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserProfileInformationRequest generates requests for UserProfileInformation
func NewUserProfileInformationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/identity/profile")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLocationListRequest generates requests for LocationList
func NewLocationListRequest(server string, params *LocationListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterZipCodeNear != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.zipCode.near", runtime.ParamLocationQuery, *params.FilterZipCodeNear); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLatLongNear != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.latLong.near", runtime.ParamLocationQuery, *params.FilterLatLongNear); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLatNear != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.lat.near", runtime.ParamLocationQuery, *params.FilterLatNear); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLonNear != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.lon.near", runtime.ParamLocationQuery, *params.FilterLonNear); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterRadiusInMiles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.radiusInMiles", runtime.ParamLocationQuery, *params.FilterRadiusInMiles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.limit", runtime.ParamLocationQuery, *params.FilterLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterChain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.chain", runtime.ParamLocationQuery, *params.FilterChain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterDepartment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.department", runtime.ParamLocationQuery, *params.FilterDepartment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLocationDetailsRequest generates requests for LocationDetails
func NewLocationDetailsRequest(server string, locationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "locationId", runtime.ParamLocationPath, locationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductSearchRequest generates requests for ProductSearch
func NewProductSearchRequest(server string, params *ProductSearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.term", runtime.ParamLocationQuery, *params.FilterTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLocationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.locationId", runtime.ParamLocationQuery, *params.FilterLocationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterProductId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.productId", runtime.ParamLocationQuery, *params.FilterProductId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterBrand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.brand", runtime.ParamLocationQuery, *params.FilterBrand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterFulfillment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.fulfillment", runtime.ParamLocationQuery, *params.FilterFulfillment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.start", runtime.ParamLocationQuery, *params.FilterStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.limit", runtime.ParamLocationQuery, *params.FilterLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductDetailsRequest generates requests for ProductDetails
func NewProductDetailsRequest(server string, id string, params *ProductDetailsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterLocationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.locationId", runtime.ParamLocationQuery, *params.FilterLocationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AddToCartWithBodyWithResponse request with any body
	AddToCartWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddToCartResponse, error)

	AddToCartWithResponse(ctx context.Context, body AddToCartJSONRequestBody, reqEditors ...RequestEditorFn) (*AddToCartResponse, error)

	// ChainListWithResponse request
	ChainListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ChainListResponse, error)

	// ChainDetailsWithResponse request
	ChainDetailsWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*ChainDetailsResponse, error)

	// DepartmentListWithResponse request
	DepartmentListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DepartmentListResponse, error)

	// DepartmentDetailsWithResponse request
	DepartmentDetailsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DepartmentDetailsResponse, error)

	// UserProfileInformationWithResponse request
	UserProfileInformationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserProfileInformationResponse, error)

	// LocationListWithResponse request
	LocationListWithResponse(ctx context.Context, params *LocationListParams, reqEditors ...RequestEditorFn) (*LocationListResponse, error)

	// LocationDetailsWithResponse request
	LocationDetailsWithResponse(ctx context.Context, locationId string, reqEditors ...RequestEditorFn) (*LocationDetailsResponse, error)

	// ProductSearchWithResponse request
	ProductSearchWithResponse(ctx context.Context, params *ProductSearchParams, reqEditors ...RequestEditorFn) (*ProductSearchResponse, error)

	// ProductDetailsWithResponse request
	ProductDetailsWithResponse(ctx context.Context, id string, params *ProductDetailsParams, reqEditors ...RequestEditorFn) (*ProductDetailsResponse, error)
}

type AddToCartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *string `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *struct {
			Error            *string `json:"error,omitempty"`
			ErrorDescription *string `json:"error_description,omitempty"`
		} `json:"errors,omitempty"`
	}
	JSON500 *struct {
		Errors *struct {
			Code      *string  `json:"code,omitempty"`
			Reason    *string  `json:"reason,omitempty"`
			Timestamp *float32 `json:"timestamp,omitempty"`
		} `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddToCartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddToCartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChainListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			DivisionNumbers *[]string `json:"divisionNumbers,omitempty"`
			Name            *string   `json:"name,omitempty"`
		} `json:"data,omitempty"`
		Meta *struct {
			Pagination *struct {
				Limit *float32 `json:"limit,omitempty"`
				Start *float32 `json:"start,omitempty"`
				Total *float32 `json:"total,omitempty"`
			} `json:"pagination,omitempty"`
			Warnings *[]string `json:"warnings,omitempty"`
		} `json:"meta,omitempty"`
	}
	JSON400 *struct {
		Errors *string `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *struct {
			Error            *string `json:"error,omitempty"`
			ErrorDescription *string `json:"error_description,omitempty"`
		} `json:"errors,omitempty"`
	}
	JSON500 *struct {
		Errors *struct {
			Code      *string  `json:"code,omitempty"`
			Reason    *string  `json:"reason,omitempty"`
			Timestamp *float32 `json:"timestamp,omitempty"`
		} `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ChainListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChainListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChainDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DivisionNumbers *[]string `json:"divisionNumbers,omitempty"`
			Name            *string   `json:"name,omitempty"`
		} `json:"data,omitempty"`
		Meta *map[string]interface{} `json:"meta,omitempty"`
	}
	JSON401 *struct {
		Errors *struct {
			Error            *string `json:"error,omitempty"`
			ErrorDescription *string `json:"error_description,omitempty"`
		} `json:"errors,omitempty"`
	}
	JSON500 *struct {
		Errors *struct {
			Code      *string  `json:"code,omitempty"`
			Reason    *string  `json:"reason,omitempty"`
			Timestamp *float32 `json:"timestamp,omitempty"`
		} `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ChainDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChainDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DepartmentListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			DepartmentId *string `json:"departmentId,omitempty"`
			Name         *string `json:"name,omitempty"`
		} `json:"data,omitempty"`
		Meta *struct {
			Pagination *struct {
				Limit *float32 `json:"limit,omitempty"`
				Start *float32 `json:"start,omitempty"`
				Total *float32 `json:"total,omitempty"`
			} `json:"pagination,omitempty"`
			Warnings *[]string `json:"warnings,omitempty"`
		} `json:"meta,omitempty"`
	}
	JSON401 *struct {
		Errors *struct {
			Error            *string `json:"error,omitempty"`
			ErrorDescription *string `json:"error_description,omitempty"`
		} `json:"errors,omitempty"`
	}
	JSON500 *struct {
		Errors *struct {
			Code      *string  `json:"code,omitempty"`
			Reason    *string  `json:"reason,omitempty"`
			Timestamp *float32 `json:"timestamp,omitempty"`
		} `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DepartmentListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DepartmentListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DepartmentDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DepartmentId *string `json:"departmentId,omitempty"`
			Name         *string `json:"name,omitempty"`
		} `json:"data,omitempty"`
		Meta *map[string]interface{} `json:"meta,omitempty"`
	}
	JSON400 *struct {
		Errors *struct {
			Code      *string  `json:"code,omitempty"`
			Reason    *string  `json:"reason,omitempty"`
			Timestamp *float32 `json:"timestamp,omitempty"`
		} `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *struct {
			Error            *string `json:"error,omitempty"`
			ErrorDescription *string `json:"error_description,omitempty"`
		} `json:"errors,omitempty"`
	}
	JSON500 *struct {
		Errors *struct {
			Code      *string  `json:"code,omitempty"`
			Reason    *string  `json:"reason,omitempty"`
			Timestamp *float32 `json:"timestamp,omitempty"`
		} `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DepartmentDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DepartmentDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserProfileInformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Id *map[string]interface{} `json:"id,omitempty"`
		} `json:"data,omitempty"`
		Meta *struct {
			Pagination *struct {
				Limit *float32 `json:"limit,omitempty"`
				Start *float32 `json:"start,omitempty"`
				Total *float32 `json:"total,omitempty"`
			} `json:"pagination,omitempty"`
			Warnings *[]string `json:"warnings,omitempty"`
		} `json:"meta,omitempty"`
	}
	JSON401 *struct {
		Errors *struct {
			Error            *string `json:"error,omitempty"`
			ErrorDescription *string `json:"error_description,omitempty"`
		} `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *struct {
			Code      *string  `json:"code,omitempty"`
			Reason    *string  `json:"reason,omitempty"`
			Timestamp *float32 `json:"timestamp,omitempty"`
		} `json:"errors,omitempty"`
	}
	JSON500 *struct {
		Errors *struct {
			Code      *string  `json:"code,omitempty"`
			Reason    *string  `json:"reason,omitempty"`
			Timestamp *float32 `json:"timestamp,omitempty"`
		} `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UserProfileInformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserProfileInformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LocationListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			Address *struct {
				AddressLine1 *string `json:"addressLine1,omitempty"`
				AddressLine2 *string `json:"addressLine2,omitempty"`
				City         *string `json:"city,omitempty"`
				County       *string `json:"county,omitempty"`
				State        *string `json:"state,omitempty"`
				ZipCode      *string `json:"zipCode,omitempty"`
			} `json:"address,omitempty"`
			Chain       *string `json:"chain,omitempty"`
			Departments *[]struct {
				DepartmentId *string `json:"departmentId,omitempty"`
				Hours        *struct {
					Open24 *bool `json:"Open24,omitempty"`
					Friday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"friday,omitempty"`
					Monday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"monday,omitempty"`
					Saturday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"saturday,omitempty"`
					Sunday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"sunday,omitempty"`
					Thursday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"thursday,omitempty"`
					Tuesday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"tuesday,omitempty"`
					Wednesday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"wednesday,omitempty"`
				} `json:"hours,omitempty"`
				Name  *string `json:"name,omitempty"`
				Phone *string `json:"phone,omitempty"`
			} `json:"departments,omitempty"`
			DivisionNumber *string `json:"divisionNumber,omitempty"`
			Geolocation    *struct {
				LatLng    *string  `json:"latLng,omitempty"`
				Latitude  *float32 `json:"latitude,omitempty"`
				Longitude *float32 `json:"longitude,omitempty"`
			} `json:"geolocation,omitempty"`
			Hours *struct {
				Open24 *bool `json:"Open24,omitempty"`
				Friday *struct {
					Close  *string `json:"close,omitempty"`
					Open   *string `json:"open,omitempty"`
					Open24 *bool   `json:"open24,omitempty"`
				} `json:"friday,omitempty"`
				GmtOffset *string `json:"gmtOffset,omitempty"`
				Monday    *struct {
					Close  *string `json:"close,omitempty"`
					Open   *string `json:"open,omitempty"`
					Open24 *bool   `json:"open24,omitempty"`
				} `json:"monday,omitempty"`
				Saturday *struct {
					Close  *string `json:"close,omitempty"`
					Open   *string `json:"open,omitempty"`
					Open24 *bool   `json:"open24,omitempty"`
				} `json:"saturday,omitempty"`
				Sunday *struct {
					Close  *string `json:"close,omitempty"`
					Open   *string `json:"open,omitempty"`
					Open24 *bool   `json:"open24,omitempty"`
				} `json:"sunday,omitempty"`
				Thursday *struct {
					Close  *string `json:"close,omitempty"`
					Open   *string `json:"open,omitempty"`
					Open24 *bool   `json:"open24,omitempty"`
				} `json:"thursday,omitempty"`
				Timezone *string `json:"timezone,omitempty"`
				Tuesday  *struct {
					Close  *string `json:"close,omitempty"`
					Open   *string `json:"open,omitempty"`
					Open24 *bool   `json:"open24,omitempty"`
				} `json:"tuesday,omitempty"`
				Wednesday *struct {
					Close  *string `json:"close,omitempty"`
					Open   *string `json:"open,omitempty"`
					Open24 *bool   `json:"open24,omitempty"`
				} `json:"wednesday,omitempty"`
			} `json:"hours,omitempty"`
			LocationId  *string `json:"locationId,omitempty"`
			Name        *string `json:"name,omitempty"`
			Phone       *string `json:"phone,omitempty"`
			StoreNumber *string `json:"storeNumber,omitempty"`
		} `json:"data,omitempty"`
		Meta *struct {
			Pagination *struct {
				Limit *float32 `json:"limit,omitempty"`
				Start *float32 `json:"start,omitempty"`
				Total *float32 `json:"total,omitempty"`
			} `json:"pagination,omitempty"`
			Warnings *[]string `json:"warnings,omitempty"`
		} `json:"meta,omitempty"`
	}
	JSON400 *struct {
		Errors *string `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *struct {
			Error            *string `json:"error,omitempty"`
			ErrorDescription *string `json:"error_description,omitempty"`
		} `json:"errors,omitempty"`
	}
	JSON500 *struct {
		Errors *struct {
			Code      *string  `json:"code,omitempty"`
			Reason    *string  `json:"reason,omitempty"`
			Timestamp *float32 `json:"timestamp,omitempty"`
		} `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r LocationListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LocationListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LocationDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Address *struct {
				AddressLine1 *string `json:"addressLine1,omitempty"`
				AddressLine2 *string `json:"addressLine2,omitempty"`
				City         *string `json:"city,omitempty"`
				County       *string `json:"county,omitempty"`
				State        *string `json:"state,omitempty"`
				ZipCode      *string `json:"zipCode,omitempty"`
			} `json:"address,omitempty"`
			Chain       *string `json:"chain,omitempty"`
			Departments *[]struct {
				DepartmentId *string `json:"departmentId,omitempty"`
				Hours        *struct {
					Open24 *bool `json:"Open24,omitempty"`
					Friday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"friday,omitempty"`
					Monday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"monday,omitempty"`
					Saturday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"saturday,omitempty"`
					Sunday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"sunday,omitempty"`
					Thursday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"thursday,omitempty"`
					Tuesday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"tuesday,omitempty"`
					Wednesday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"wednesday,omitempty"`
				} `json:"hours,omitempty"`
				Name  *string `json:"name,omitempty"`
				Phone *string `json:"phone,omitempty"`
			} `json:"departments,omitempty"`
			DivisionNumber *string `json:"divisionNumber,omitempty"`
			Geolocation    *struct {
				LatLng    *string  `json:"latLng,omitempty"`
				Latitude  *float32 `json:"latitude,omitempty"`
				Longitude *float32 `json:"longitude,omitempty"`
			} `json:"geolocation,omitempty"`
			Hours *struct {
				Open24 *bool `json:"Open24,omitempty"`
				Friday *struct {
					Close  *string `json:"close,omitempty"`
					Open   *string `json:"open,omitempty"`
					Open24 *bool   `json:"open24,omitempty"`
				} `json:"friday,omitempty"`
				GmtOffset *string `json:"gmtOffset,omitempty"`
				Monday    *struct {
					Close  *string `json:"close,omitempty"`
					Open   *string `json:"open,omitempty"`
					Open24 *bool   `json:"open24,omitempty"`
				} `json:"monday,omitempty"`
				Saturday *struct {
					Close  *string `json:"close,omitempty"`
					Open   *string `json:"open,omitempty"`
					Open24 *bool   `json:"open24,omitempty"`
				} `json:"saturday,omitempty"`
				Sunday *struct {
					Close  *string `json:"close,omitempty"`
					Open   *string `json:"open,omitempty"`
					Open24 *bool   `json:"open24,omitempty"`
				} `json:"sunday,omitempty"`
				Thursday *struct {
					Close  *string `json:"close,omitempty"`
					Open   *string `json:"open,omitempty"`
					Open24 *bool   `json:"open24,omitempty"`
				} `json:"thursday,omitempty"`
				Timezone *string `json:"timezone,omitempty"`
				Tuesday  *struct {
					Close  *string `json:"close,omitempty"`
					Open   *string `json:"open,omitempty"`
					Open24 *bool   `json:"open24,omitempty"`
				} `json:"tuesday,omitempty"`
				Wednesday *struct {
					Close  *string `json:"close,omitempty"`
					Open   *string `json:"open,omitempty"`
					Open24 *bool   `json:"open24,omitempty"`
				} `json:"wednesday,omitempty"`
			} `json:"hours,omitempty"`
			LocationId  *string `json:"locationId,omitempty"`
			Name        *string `json:"name,omitempty"`
			Phone       *string `json:"phone,omitempty"`
			StoreNumber *string `json:"storeNumber,omitempty"`
		} `json:"data,omitempty"`
		Meta *struct {
			Pagination *struct {
				Limit *float32 `json:"limit,omitempty"`
				Start *float32 `json:"start,omitempty"`
				Total *float32 `json:"total,omitempty"`
			} `json:"pagination,omitempty"`
			Warnings *[]string `json:"warnings,omitempty"`
		} `json:"meta,omitempty"`
	}
	JSON400 *struct {
		Errors *struct {
			Code      *string  `json:"code,omitempty"`
			Reason    *string  `json:"reason,omitempty"`
			Timestamp *float32 `json:"timestamp,omitempty"`
		} `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *struct {
			Error            *string `json:"error,omitempty"`
			ErrorDescription *string `json:"error_description,omitempty"`
		} `json:"errors,omitempty"`
	}
	JSON500 *struct {
		Errors *struct {
			Code      *string  `json:"code,omitempty"`
			Reason    *string  `json:"reason,omitempty"`
			Timestamp *float32 `json:"timestamp,omitempty"`
		} `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r LocationDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LocationDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			AisleLocations *[]struct {
				BayNumber          *string `json:"bayNumber,omitempty"`
				Description        *string `json:"description,omitempty"`
				Number             *string `json:"number,omitempty"`
				NumberOfFacings    *string `json:"numberOfFacings,omitempty"`
				SequenceNumber     *string `json:"sequenceNumber,omitempty"`
				ShelfNumber        *string `json:"shelfNumber,omitempty"`
				ShelfPositionInBay *string `json:"shelfPositionInBay,omitempty"`
				Side               *string `json:"side,omitempty"`
			} `json:"aisleLocations,omitempty"`
			Brand         *string   `json:"brand,omitempty"`
			Categories    *[]string `json:"categories,omitempty"`
			CountryOrigin *string   `json:"countryOrigin,omitempty"`
			Description   *string   `json:"description,omitempty"`
			Images        *[]struct {
				Default *bool   `json:"default,omitempty"`
				Type    *string `json:"type,omitempty"`
			} `json:"images,omitempty"`
			ItemInformation *struct {
				Depth  *string `json:"depth,omitempty"`
				Height *string `json:"height,omitempty"`
				Width  *string `json:"width,omitempty"`
			} `json:"itemInformation,omitempty"`
			Items *[]struct {
				Favorite    *bool `json:"favorite,omitempty"`
				Fulfillment *struct {
					Curbside *bool `json:"curbside,omitempty"`
					Delivery *bool `json:"delivery,omitempty"`
				} `json:"fulfillment,omitempty"`
				Inventory *struct {
					StockLevel *string `json:"stockLevel,omitempty"`
				} `json:"inventory,omitempty"`
				ItemId *string `json:"itemId,omitempty"`
				Price  *struct {
					Promo   *float32 `json:"promo,omitempty"`
					Regular *float32 `json:"regular,omitempty"`
				} `json:"price,omitempty"`
				Size *string `json:"size,omitempty"`
			} `json:"items,omitempty"`
			ProductId   *string `json:"productId,omitempty"`
			Temperature *struct {
				HeatSensitive *bool   `json:"heatSensitive,omitempty"`
				Indicator     *string `json:"indicator,omitempty"`
			} `json:"temperature,omitempty"`
			Upc *string `json:"upc,omitempty"`
		} `json:"data,omitempty"`
		Meta *struct {
			Pagination *struct {
				Limit *float32 `json:"limit,omitempty"`
				Start *float32 `json:"start,omitempty"`
				Total *float32 `json:"total,omitempty"`
			} `json:"pagination,omitempty"`
			Warnings *[]string `json:"warnings,omitempty"`
		} `json:"meta,omitempty"`
	}
	JSON400 *struct {
		Errors *string `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *struct {
			Error            *string `json:"error,omitempty"`
			ErrorDescription *string `json:"error_description,omitempty"`
		} `json:"errors,omitempty"`
	}
	JSON500 *struct {
		Errors *struct {
			Code      *string  `json:"code,omitempty"`
			Reason    *string  `json:"reason,omitempty"`
			Timestamp *float32 `json:"timestamp,omitempty"`
		} `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ProductSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			AisleLocations *[]struct {
				BayNumber          *string `json:"bayNumber,omitempty"`
				Description        *string `json:"description,omitempty"`
				Number             *string `json:"number,omitempty"`
				NumberOfFacings    *string `json:"numberOfFacings,omitempty"`
				SequenceNumber     *string `json:"sequenceNumber,omitempty"`
				ShelfNumber        *string `json:"shelfNumber,omitempty"`
				ShelfPositionInBay *string `json:"shelfPositionInBay,omitempty"`
				Side               *string `json:"side,omitempty"`
			} `json:"aisleLocations,omitempty"`
			Brand         *string   `json:"brand,omitempty"`
			Categories    *[]string `json:"categories,omitempty"`
			CountryOrigin *string   `json:"countryOrigin,omitempty"`
			Description   *string   `json:"description,omitempty"`
			Images        *[]struct {
				Default *bool   `json:"default,omitempty"`
				Type    *string `json:"type,omitempty"`
			} `json:"images,omitempty"`
			ItemInformation *struct {
				Depth  *string `json:"depth,omitempty"`
				Height *string `json:"height,omitempty"`
				Width  *string `json:"width,omitempty"`
			} `json:"itemInformation,omitempty"`
			Items *[]struct {
				Favorite    *bool `json:"favorite,omitempty"`
				Fulfillment *struct {
					Curbside *bool `json:"curbside,omitempty"`
					Delivery *bool `json:"delivery,omitempty"`
				} `json:"fulfillment,omitempty"`
				Inventory *struct {
					StockLevel *string `json:"stockLevel,omitempty"`
				} `json:"inventory,omitempty"`
				ItemId *string `json:"itemId,omitempty"`
				Price  *struct {
					Promo   *float32 `json:"promo,omitempty"`
					Regular *float32 `json:"regular,omitempty"`
				} `json:"price,omitempty"`
				Size *string `json:"size,omitempty"`
			} `json:"items,omitempty"`
			ProductId   *string `json:"productId,omitempty"`
			Temperature *struct {
				HeatSensitive *bool   `json:"heatSensitive,omitempty"`
				Indicator     *string `json:"indicator,omitempty"`
			} `json:"temperature,omitempty"`
			Upc *string `json:"upc,omitempty"`
		} `json:"data,omitempty"`
		Meta *struct {
			Pagination *struct {
				Limit *float32 `json:"limit,omitempty"`
				Start *float32 `json:"start,omitempty"`
				Total *float32 `json:"total,omitempty"`
			} `json:"pagination,omitempty"`
			Warnings *[]string `json:"warnings,omitempty"`
		} `json:"meta,omitempty"`
	}
	JSON400 *struct {
		Errors *struct {
			Code      *string  `json:"code,omitempty"`
			Reason    *string  `json:"reason,omitempty"`
			Timestamp *float32 `json:"timestamp,omitempty"`
		} `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *struct {
			Error            *string `json:"error,omitempty"`
			ErrorDescription *string `json:"error_description,omitempty"`
		} `json:"errors,omitempty"`
	}
	JSON500 *struct {
		Errors *struct {
			Code      *string  `json:"code,omitempty"`
			Reason    *string  `json:"reason,omitempty"`
			Timestamp *float32 `json:"timestamp,omitempty"`
		} `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ProductDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AddToCartWithBodyWithResponse request with arbitrary body returning *AddToCartResponse
func (c *ClientWithResponses) AddToCartWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddToCartResponse, error) {
	rsp, err := c.AddToCartWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddToCartResponse(rsp)
}

func (c *ClientWithResponses) AddToCartWithResponse(ctx context.Context, body AddToCartJSONRequestBody, reqEditors ...RequestEditorFn) (*AddToCartResponse, error) {
	rsp, err := c.AddToCart(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddToCartResponse(rsp)
}

// ChainListWithResponse request returning *ChainListResponse
func (c *ClientWithResponses) ChainListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ChainListResponse, error) {
	rsp, err := c.ChainList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChainListResponse(rsp)
}

// ChainDetailsWithResponse request returning *ChainDetailsResponse
func (c *ClientWithResponses) ChainDetailsWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*ChainDetailsResponse, error) {
	rsp, err := c.ChainDetails(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChainDetailsResponse(rsp)
}

// DepartmentListWithResponse request returning *DepartmentListResponse
func (c *ClientWithResponses) DepartmentListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DepartmentListResponse, error) {
	rsp, err := c.DepartmentList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDepartmentListResponse(rsp)
}

// DepartmentDetailsWithResponse request returning *DepartmentDetailsResponse
func (c *ClientWithResponses) DepartmentDetailsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DepartmentDetailsResponse, error) {
	rsp, err := c.DepartmentDetails(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDepartmentDetailsResponse(rsp)
}

// UserProfileInformationWithResponse request returning *UserProfileInformationResponse
func (c *ClientWithResponses) UserProfileInformationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserProfileInformationResponse, error) {
	rsp, err := c.UserProfileInformation(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserProfileInformationResponse(rsp)
}

// LocationListWithResponse request returning *LocationListResponse
func (c *ClientWithResponses) LocationListWithResponse(ctx context.Context, params *LocationListParams, reqEditors ...RequestEditorFn) (*LocationListResponse, error) {
	rsp, err := c.LocationList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLocationListResponse(rsp)
}

// LocationDetailsWithResponse request returning *LocationDetailsResponse
func (c *ClientWithResponses) LocationDetailsWithResponse(ctx context.Context, locationId string, reqEditors ...RequestEditorFn) (*LocationDetailsResponse, error) {
	rsp, err := c.LocationDetails(ctx, locationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLocationDetailsResponse(rsp)
}

// ProductSearchWithResponse request returning *ProductSearchResponse
func (c *ClientWithResponses) ProductSearchWithResponse(ctx context.Context, params *ProductSearchParams, reqEditors ...RequestEditorFn) (*ProductSearchResponse, error) {
	rsp, err := c.ProductSearch(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductSearchResponse(rsp)
}

// ProductDetailsWithResponse request returning *ProductDetailsResponse
func (c *ClientWithResponses) ProductDetailsWithResponse(ctx context.Context, id string, params *ProductDetailsParams, reqEditors ...RequestEditorFn) (*ProductDetailsResponse, error) {
	rsp, err := c.ProductDetails(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductDetailsResponse(rsp)
}

// ParseAddToCartResponse parses an HTTP response from a AddToCartWithResponse call
func ParseAddToCartResponse(rsp *http.Response) (*AddToCartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddToCartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *struct {
				Error            *string `json:"error,omitempty"`
				ErrorDescription *string `json:"error_description,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Errors *struct {
				Code      *string  `json:"code,omitempty"`
				Reason    *string  `json:"reason,omitempty"`
				Timestamp *float32 `json:"timestamp,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseChainListResponse parses an HTTP response from a ChainListWithResponse call
func ParseChainListResponse(rsp *http.Response) (*ChainListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChainListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				DivisionNumbers *[]string `json:"divisionNumbers,omitempty"`
				Name            *string   `json:"name,omitempty"`
			} `json:"data,omitempty"`
			Meta *struct {
				Pagination *struct {
					Limit *float32 `json:"limit,omitempty"`
					Start *float32 `json:"start,omitempty"`
					Total *float32 `json:"total,omitempty"`
				} `json:"pagination,omitempty"`
				Warnings *[]string `json:"warnings,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *struct {
				Error            *string `json:"error,omitempty"`
				ErrorDescription *string `json:"error_description,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Errors *struct {
				Code      *string  `json:"code,omitempty"`
				Reason    *string  `json:"reason,omitempty"`
				Timestamp *float32 `json:"timestamp,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseChainDetailsResponse parses an HTTP response from a ChainDetailsWithResponse call
func ParseChainDetailsResponse(rsp *http.Response) (*ChainDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChainDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DivisionNumbers *[]string `json:"divisionNumbers,omitempty"`
				Name            *string   `json:"name,omitempty"`
			} `json:"data,omitempty"`
			Meta *map[string]interface{} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *struct {
				Error            *string `json:"error,omitempty"`
				ErrorDescription *string `json:"error_description,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Errors *struct {
				Code      *string  `json:"code,omitempty"`
				Reason    *string  `json:"reason,omitempty"`
				Timestamp *float32 `json:"timestamp,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDepartmentListResponse parses an HTTP response from a DepartmentListWithResponse call
func ParseDepartmentListResponse(rsp *http.Response) (*DepartmentListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DepartmentListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				DepartmentId *string `json:"departmentId,omitempty"`
				Name         *string `json:"name,omitempty"`
			} `json:"data,omitempty"`
			Meta *struct {
				Pagination *struct {
					Limit *float32 `json:"limit,omitempty"`
					Start *float32 `json:"start,omitempty"`
					Total *float32 `json:"total,omitempty"`
				} `json:"pagination,omitempty"`
				Warnings *[]string `json:"warnings,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *struct {
				Error            *string `json:"error,omitempty"`
				ErrorDescription *string `json:"error_description,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Errors *struct {
				Code      *string  `json:"code,omitempty"`
				Reason    *string  `json:"reason,omitempty"`
				Timestamp *float32 `json:"timestamp,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDepartmentDetailsResponse parses an HTTP response from a DepartmentDetailsWithResponse call
func ParseDepartmentDetailsResponse(rsp *http.Response) (*DepartmentDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DepartmentDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DepartmentId *string `json:"departmentId,omitempty"`
				Name         *string `json:"name,omitempty"`
			} `json:"data,omitempty"`
			Meta *map[string]interface{} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *struct {
				Code      *string  `json:"code,omitempty"`
				Reason    *string  `json:"reason,omitempty"`
				Timestamp *float32 `json:"timestamp,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *struct {
				Error            *string `json:"error,omitempty"`
				ErrorDescription *string `json:"error_description,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Errors *struct {
				Code      *string  `json:"code,omitempty"`
				Reason    *string  `json:"reason,omitempty"`
				Timestamp *float32 `json:"timestamp,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUserProfileInformationResponse parses an HTTP response from a UserProfileInformationWithResponse call
func ParseUserProfileInformationResponse(rsp *http.Response) (*UserProfileInformationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserProfileInformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Id *map[string]interface{} `json:"id,omitempty"`
			} `json:"data,omitempty"`
			Meta *struct {
				Pagination *struct {
					Limit *float32 `json:"limit,omitempty"`
					Start *float32 `json:"start,omitempty"`
					Total *float32 `json:"total,omitempty"`
				} `json:"pagination,omitempty"`
				Warnings *[]string `json:"warnings,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *struct {
				Error            *string `json:"error,omitempty"`
				ErrorDescription *string `json:"error_description,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *struct {
				Code      *string  `json:"code,omitempty"`
				Reason    *string  `json:"reason,omitempty"`
				Timestamp *float32 `json:"timestamp,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Errors *struct {
				Code      *string  `json:"code,omitempty"`
				Reason    *string  `json:"reason,omitempty"`
				Timestamp *float32 `json:"timestamp,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLocationListResponse parses an HTTP response from a LocationListWithResponse call
func ParseLocationListResponse(rsp *http.Response) (*LocationListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LocationListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				Address *struct {
					AddressLine1 *string `json:"addressLine1,omitempty"`
					AddressLine2 *string `json:"addressLine2,omitempty"`
					City         *string `json:"city,omitempty"`
					County       *string `json:"county,omitempty"`
					State        *string `json:"state,omitempty"`
					ZipCode      *string `json:"zipCode,omitempty"`
				} `json:"address,omitempty"`
				Chain       *string `json:"chain,omitempty"`
				Departments *[]struct {
					DepartmentId *string `json:"departmentId,omitempty"`
					Hours        *struct {
						Open24 *bool `json:"Open24,omitempty"`
						Friday *struct {
							Close  *string `json:"close,omitempty"`
							Open   *string `json:"open,omitempty"`
							Open24 *bool   `json:"open24,omitempty"`
						} `json:"friday,omitempty"`
						Monday *struct {
							Close  *string `json:"close,omitempty"`
							Open   *string `json:"open,omitempty"`
							Open24 *bool   `json:"open24,omitempty"`
						} `json:"monday,omitempty"`
						Saturday *struct {
							Close  *string `json:"close,omitempty"`
							Open   *string `json:"open,omitempty"`
							Open24 *bool   `json:"open24,omitempty"`
						} `json:"saturday,omitempty"`
						Sunday *struct {
							Close  *string `json:"close,omitempty"`
							Open   *string `json:"open,omitempty"`
							Open24 *bool   `json:"open24,omitempty"`
						} `json:"sunday,omitempty"`
						Thursday *struct {
							Close  *string `json:"close,omitempty"`
							Open   *string `json:"open,omitempty"`
							Open24 *bool   `json:"open24,omitempty"`
						} `json:"thursday,omitempty"`
						Tuesday *struct {
							Close  *string `json:"close,omitempty"`
							Open   *string `json:"open,omitempty"`
							Open24 *bool   `json:"open24,omitempty"`
						} `json:"tuesday,omitempty"`
						Wednesday *struct {
							Close  *string `json:"close,omitempty"`
							Open   *string `json:"open,omitempty"`
							Open24 *bool   `json:"open24,omitempty"`
						} `json:"wednesday,omitempty"`
					} `json:"hours,omitempty"`
					Name  *string `json:"name,omitempty"`
					Phone *string `json:"phone,omitempty"`
				} `json:"departments,omitempty"`
				DivisionNumber *string `json:"divisionNumber,omitempty"`
				Geolocation    *struct {
					LatLng    *string  `json:"latLng,omitempty"`
					Latitude  *float32 `json:"latitude,omitempty"`
					Longitude *float32 `json:"longitude,omitempty"`
				} `json:"geolocation,omitempty"`
				Hours *struct {
					Open24 *bool `json:"Open24,omitempty"`
					Friday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"friday,omitempty"`
					GmtOffset *string `json:"gmtOffset,omitempty"`
					Monday    *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"monday,omitempty"`
					Saturday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"saturday,omitempty"`
					Sunday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"sunday,omitempty"`
					Thursday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"thursday,omitempty"`
					Timezone *string `json:"timezone,omitempty"`
					Tuesday  *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"tuesday,omitempty"`
					Wednesday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"wednesday,omitempty"`
				} `json:"hours,omitempty"`
				LocationId  *string `json:"locationId,omitempty"`
				Name        *string `json:"name,omitempty"`
				Phone       *string `json:"phone,omitempty"`
				StoreNumber *string `json:"storeNumber,omitempty"`
			} `json:"data,omitempty"`
			Meta *struct {
				Pagination *struct {
					Limit *float32 `json:"limit,omitempty"`
					Start *float32 `json:"start,omitempty"`
					Total *float32 `json:"total,omitempty"`
				} `json:"pagination,omitempty"`
				Warnings *[]string `json:"warnings,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *struct {
				Error            *string `json:"error,omitempty"`
				ErrorDescription *string `json:"error_description,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Errors *struct {
				Code      *string  `json:"code,omitempty"`
				Reason    *string  `json:"reason,omitempty"`
				Timestamp *float32 `json:"timestamp,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLocationDetailsResponse parses an HTTP response from a LocationDetailsWithResponse call
func ParseLocationDetailsResponse(rsp *http.Response) (*LocationDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LocationDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Address *struct {
					AddressLine1 *string `json:"addressLine1,omitempty"`
					AddressLine2 *string `json:"addressLine2,omitempty"`
					City         *string `json:"city,omitempty"`
					County       *string `json:"county,omitempty"`
					State        *string `json:"state,omitempty"`
					ZipCode      *string `json:"zipCode,omitempty"`
				} `json:"address,omitempty"`
				Chain       *string `json:"chain,omitempty"`
				Departments *[]struct {
					DepartmentId *string `json:"departmentId,omitempty"`
					Hours        *struct {
						Open24 *bool `json:"Open24,omitempty"`
						Friday *struct {
							Close  *string `json:"close,omitempty"`
							Open   *string `json:"open,omitempty"`
							Open24 *bool   `json:"open24,omitempty"`
						} `json:"friday,omitempty"`
						Monday *struct {
							Close  *string `json:"close,omitempty"`
							Open   *string `json:"open,omitempty"`
							Open24 *bool   `json:"open24,omitempty"`
						} `json:"monday,omitempty"`
						Saturday *struct {
							Close  *string `json:"close,omitempty"`
							Open   *string `json:"open,omitempty"`
							Open24 *bool   `json:"open24,omitempty"`
						} `json:"saturday,omitempty"`
						Sunday *struct {
							Close  *string `json:"close,omitempty"`
							Open   *string `json:"open,omitempty"`
							Open24 *bool   `json:"open24,omitempty"`
						} `json:"sunday,omitempty"`
						Thursday *struct {
							Close  *string `json:"close,omitempty"`
							Open   *string `json:"open,omitempty"`
							Open24 *bool   `json:"open24,omitempty"`
						} `json:"thursday,omitempty"`
						Tuesday *struct {
							Close  *string `json:"close,omitempty"`
							Open   *string `json:"open,omitempty"`
							Open24 *bool   `json:"open24,omitempty"`
						} `json:"tuesday,omitempty"`
						Wednesday *struct {
							Close  *string `json:"close,omitempty"`
							Open   *string `json:"open,omitempty"`
							Open24 *bool   `json:"open24,omitempty"`
						} `json:"wednesday,omitempty"`
					} `json:"hours,omitempty"`
					Name  *string `json:"name,omitempty"`
					Phone *string `json:"phone,omitempty"`
				} `json:"departments,omitempty"`
				DivisionNumber *string `json:"divisionNumber,omitempty"`
				Geolocation    *struct {
					LatLng    *string  `json:"latLng,omitempty"`
					Latitude  *float32 `json:"latitude,omitempty"`
					Longitude *float32 `json:"longitude,omitempty"`
				} `json:"geolocation,omitempty"`
				Hours *struct {
					Open24 *bool `json:"Open24,omitempty"`
					Friday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"friday,omitempty"`
					GmtOffset *string `json:"gmtOffset,omitempty"`
					Monday    *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"monday,omitempty"`
					Saturday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"saturday,omitempty"`
					Sunday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"sunday,omitempty"`
					Thursday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"thursday,omitempty"`
					Timezone *string `json:"timezone,omitempty"`
					Tuesday  *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"tuesday,omitempty"`
					Wednesday *struct {
						Close  *string `json:"close,omitempty"`
						Open   *string `json:"open,omitempty"`
						Open24 *bool   `json:"open24,omitempty"`
					} `json:"wednesday,omitempty"`
				} `json:"hours,omitempty"`
				LocationId  *string `json:"locationId,omitempty"`
				Name        *string `json:"name,omitempty"`
				Phone       *string `json:"phone,omitempty"`
				StoreNumber *string `json:"storeNumber,omitempty"`
			} `json:"data,omitempty"`
			Meta *struct {
				Pagination *struct {
					Limit *float32 `json:"limit,omitempty"`
					Start *float32 `json:"start,omitempty"`
					Total *float32 `json:"total,omitempty"`
				} `json:"pagination,omitempty"`
				Warnings *[]string `json:"warnings,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *struct {
				Code      *string  `json:"code,omitempty"`
				Reason    *string  `json:"reason,omitempty"`
				Timestamp *float32 `json:"timestamp,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *struct {
				Error            *string `json:"error,omitempty"`
				ErrorDescription *string `json:"error_description,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Errors *struct {
				Code      *string  `json:"code,omitempty"`
				Reason    *string  `json:"reason,omitempty"`
				Timestamp *float32 `json:"timestamp,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseProductSearchResponse parses an HTTP response from a ProductSearchWithResponse call
func ParseProductSearchResponse(rsp *http.Response) (*ProductSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				AisleLocations *[]struct {
					BayNumber          *string `json:"bayNumber,omitempty"`
					Description        *string `json:"description,omitempty"`
					Number             *string `json:"number,omitempty"`
					NumberOfFacings    *string `json:"numberOfFacings,omitempty"`
					SequenceNumber     *string `json:"sequenceNumber,omitempty"`
					ShelfNumber        *string `json:"shelfNumber,omitempty"`
					ShelfPositionInBay *string `json:"shelfPositionInBay,omitempty"`
					Side               *string `json:"side,omitempty"`
				} `json:"aisleLocations,omitempty"`
				Brand         *string   `json:"brand,omitempty"`
				Categories    *[]string `json:"categories,omitempty"`
				CountryOrigin *string   `json:"countryOrigin,omitempty"`
				Description   *string   `json:"description,omitempty"`
				Images        *[]struct {
					Default *bool   `json:"default,omitempty"`
					Type    *string `json:"type,omitempty"`
				} `json:"images,omitempty"`
				ItemInformation *struct {
					Depth  *string `json:"depth,omitempty"`
					Height *string `json:"height,omitempty"`
					Width  *string `json:"width,omitempty"`
				} `json:"itemInformation,omitempty"`
				Items *[]struct {
					Favorite    *bool `json:"favorite,omitempty"`
					Fulfillment *struct {
						Curbside *bool `json:"curbside,omitempty"`
						Delivery *bool `json:"delivery,omitempty"`
					} `json:"fulfillment,omitempty"`
					Inventory *struct {
						StockLevel *string `json:"stockLevel,omitempty"`
					} `json:"inventory,omitempty"`
					ItemId *string `json:"itemId,omitempty"`
					Price  *struct {
						Promo   *float32 `json:"promo,omitempty"`
						Regular *float32 `json:"regular,omitempty"`
					} `json:"price,omitempty"`
					Size *string `json:"size,omitempty"`
				} `json:"items,omitempty"`
				ProductId   *string `json:"productId,omitempty"`
				Temperature *struct {
					HeatSensitive *bool   `json:"heatSensitive,omitempty"`
					Indicator     *string `json:"indicator,omitempty"`
				} `json:"temperature,omitempty"`
				Upc *string `json:"upc,omitempty"`
			} `json:"data,omitempty"`
			Meta *struct {
				Pagination *struct {
					Limit *float32 `json:"limit,omitempty"`
					Start *float32 `json:"start,omitempty"`
					Total *float32 `json:"total,omitempty"`
				} `json:"pagination,omitempty"`
				Warnings *[]string `json:"warnings,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *struct {
				Error            *string `json:"error,omitempty"`
				ErrorDescription *string `json:"error_description,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Errors *struct {
				Code      *string  `json:"code,omitempty"`
				Reason    *string  `json:"reason,omitempty"`
				Timestamp *float32 `json:"timestamp,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseProductDetailsResponse parses an HTTP response from a ProductDetailsWithResponse call
func ParseProductDetailsResponse(rsp *http.Response) (*ProductDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				AisleLocations *[]struct {
					BayNumber          *string `json:"bayNumber,omitempty"`
					Description        *string `json:"description,omitempty"`
					Number             *string `json:"number,omitempty"`
					NumberOfFacings    *string `json:"numberOfFacings,omitempty"`
					SequenceNumber     *string `json:"sequenceNumber,omitempty"`
					ShelfNumber        *string `json:"shelfNumber,omitempty"`
					ShelfPositionInBay *string `json:"shelfPositionInBay,omitempty"`
					Side               *string `json:"side,omitempty"`
				} `json:"aisleLocations,omitempty"`
				Brand         *string   `json:"brand,omitempty"`
				Categories    *[]string `json:"categories,omitempty"`
				CountryOrigin *string   `json:"countryOrigin,omitempty"`
				Description   *string   `json:"description,omitempty"`
				Images        *[]struct {
					Default *bool   `json:"default,omitempty"`
					Type    *string `json:"type,omitempty"`
				} `json:"images,omitempty"`
				ItemInformation *struct {
					Depth  *string `json:"depth,omitempty"`
					Height *string `json:"height,omitempty"`
					Width  *string `json:"width,omitempty"`
				} `json:"itemInformation,omitempty"`
				Items *[]struct {
					Favorite    *bool `json:"favorite,omitempty"`
					Fulfillment *struct {
						Curbside *bool `json:"curbside,omitempty"`
						Delivery *bool `json:"delivery,omitempty"`
					} `json:"fulfillment,omitempty"`
					Inventory *struct {
						StockLevel *string `json:"stockLevel,omitempty"`
					} `json:"inventory,omitempty"`
					ItemId *string `json:"itemId,omitempty"`
					Price  *struct {
						Promo   *float32 `json:"promo,omitempty"`
						Regular *float32 `json:"regular,omitempty"`
					} `json:"price,omitempty"`
					Size *string `json:"size,omitempty"`
				} `json:"items,omitempty"`
				ProductId   *string `json:"productId,omitempty"`
				Temperature *struct {
					HeatSensitive *bool   `json:"heatSensitive,omitempty"`
					Indicator     *string `json:"indicator,omitempty"`
				} `json:"temperature,omitempty"`
				Upc *string `json:"upc,omitempty"`
			} `json:"data,omitempty"`
			Meta *struct {
				Pagination *struct {
					Limit *float32 `json:"limit,omitempty"`
					Start *float32 `json:"start,omitempty"`
					Total *float32 `json:"total,omitempty"`
				} `json:"pagination,omitempty"`
				Warnings *[]string `json:"warnings,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *struct {
				Code      *string  `json:"code,omitempty"`
				Reason    *string  `json:"reason,omitempty"`
				Timestamp *float32 `json:"timestamp,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *struct {
				Error            *string `json:"error,omitempty"`
				ErrorDescription *string `json:"error_description,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Errors *struct {
				Code      *string  `json:"code,omitempty"`
				Reason    *string  `json:"reason,omitempty"`
				Timestamp *float32 `json:"timestamp,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
